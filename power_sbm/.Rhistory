B <- diag(a-b,d) + matrix(b,d,d)
d <- 3
a <- .4
b <- .8
nsims <- 100
m <- n
B <- diag(a-b,d) + matrix(b,d,d)
B
B2 <- B + diag(eps,d)
B2
nus1 <- eigen(B)
nus_true1 <- nus1$vectors %*% diag(abs(nus1$values)^(1/2),d,d)
nus2 <- eigen(B2)
nus_true2 <- nus2$vectors %*% diag(abs(nus2$values)^(1/2),d,d)
Ipq <- diag(c(1,rep(-1,(d-1))),d,d)
pis <- rep(1/d,d)
sigma <- 1/2
p <- 1
toReturn <- rep(0,nsims)
set.seed(472022)
n <- 600
eps <- 0
d <- 3
a <- .4
b <- .8
nsims <- 100
m <- n
B <- diag(a-b,d) + matrix(b,d,d)
B2 <- B + diag(eps,d)
nus1 <- eigen(B)
nus_true1 <- nus1$vectors %*% diag(abs(nus1$values)^(1/2),d,d)
nus2 <- eigen(B2)
nus_true2 <- nus2$vectors %*% diag(abs(nus2$values)^(1/2),d,d)
Ipq <- diag(c(1,rep(-1,(d-1))),d,d)
pis <- rep(1/d,d)
sigma <- 1/2
p <- 1
toReturn <- rep(0,nsims)
for (iter in c(1:nsims)) {
print(paste0("iter = ",iter, " of ",max(nsims)
,", n = ",n," of ",max(ns),
", eps = ",eps," of ",max(epses)))
assignmentvector1 <- rmultinom(n,1,pis)
assignmentvector2 <- rmultinom(m,1,pis)
Xtrue <-t(assignmentvector1) %*% nus_true1
Ytrue <-  t(assignmentvector2) %*% nus_true2
P1 <- Xtrue %*%Ipq %*% t(Xtrue)
P2 <- Ytrue %*% Ipq %*% t(Ytrue)
A <- generateAdjacencyMatrix(P1)
C <- generateAdjacencyMatrix(P2)
Xhat <- ase(A,d)
Yhat <- ase(C,d)
rm(A,C,P1,P2)
#Qinit <- get_sign(Xhat,Yhat)
#Qinit2 <- Qinit[c((p+1):d),c((p+1):d)]
Q <- align_matrices_cheap(Xhat,Yhat,lambda=.0001,eps=.001,niter=200)
#Q <- OTP(Xhat[,c((p+1):d)],Yhat[,c((p+1):d)],Qinit=Qinit2,lambda=.0001,eps=.0001,niter=300)
#Xnew <- Xhat%*% bdiag(Qinit[1,1],Q)
Xnew <- Xhat %*% Q
#run test:
test <- nonpar.test(Xnew,Yhat,nsims=1000)
toReturn[iter] <- test$`estimated p-value`
}
ns <- 600
epses <- 0
d <- 3
a <- .4
b <- .8
nsims <- 100
m <- n
B <- diag(a-b,d) + matrix(b,d,d)
B2 <- B + diag(eps,d)
nus1 <- eigen(B)
nus_true1 <- nus1$vectors %*% diag(abs(nus1$values)^(1/2),d,d)
nus2 <- eigen(B2)
nus_true2 <- nus2$vectors %*% diag(abs(nus2$values)^(1/2),d,d)
Ipq <- diag(c(1,rep(-1,(d-1))),d,d)
pis <- rep(1/d,d)
sigma <- 1/2
p <- 1
toReturn <- rep(0,nsims)
for (iter in c(1:nsims)) {
print(paste0("iter = ",iter, " of ",max(nsims)
,", n = ",n," of ",max(ns),
", eps = ",eps," of ",max(epses)))
assignmentvector1 <- rmultinom(n,1,pis)
assignmentvector2 <- rmultinom(m,1,pis)
Xtrue <-t(assignmentvector1) %*% nus_true1
Ytrue <-  t(assignmentvector2) %*% nus_true2
P1 <- Xtrue %*%Ipq %*% t(Xtrue)
P2 <- Ytrue %*% Ipq %*% t(Ytrue)
A <- generateAdjacencyMatrix(P1)
C <- generateAdjacencyMatrix(P2)
Xhat <- ase(A,d)
Yhat <- ase(C,d)
rm(A,C,P1,P2)
#Qinit <- get_sign(Xhat,Yhat)
#Qinit2 <- Qinit[c((p+1):d),c((p+1):d)]
Q <- align_matrices_cheap(Xhat,Yhat,lambda=.0001,eps=.001,niter=200)
#Q <- OTP(Xhat[,c((p+1):d)],Yhat[,c((p+1):d)],Qinit=Qinit2,lambda=.0001,eps=.0001,niter=300)
#Xnew <- Xhat%*% bdiag(Qinit[1,1],Q)
Xnew <- Xhat %*% Q
#run test:
test <- nonpar.test(Xnew,Yhat,nsims=1000)
toReturn[iter] <- test$`estimated p-value`
}
for (iter in c(1:nsims)) {
print(paste0("iter = ",iter, " of ",max(nsims)
,", n = ",n," of ",max(ns),
", eps = ",eps," of ",max(epses)))
assignmentvector1 <- rmultinom(n,1,pis)
assignmentvector2 <- rmultinom(m,1,pis)
Xtrue <-t(assignmentvector1) %*% nus_true1
Ytrue <-  t(assignmentvector2) %*% nus_true2
P1 <- Xtrue %*%Ipq %*% t(Xtrue)
P2 <- Ytrue %*% Ipq %*% t(Ytrue)
A <- generateAdjacencyMatrix(P1)
C <- generateAdjacencyMatrix(P2)
Xhat <- ase(A,d)
Yhat <- ase(C,d)
rm(A,C,P1,P2)
#Qinit <- get_sign(Xhat,Yhat)
#Qinit2 <- Qinit[c((p+1):d),c((p+1):d)]
Q <- align_matrices_cheap(Xhat,Yhat,lambda=.01,eps=.01,niter=100)
#Q <- OTP(Xhat[,c((p+1):d)],Yhat[,c((p+1):d)],Qinit=Qinit2,lambda=.0001,eps=.0001,niter=300)
#Xnew <- Xhat%*% bdiag(Qinit[1,1],Q)
Xnew <- Xhat %*% Q
#run test:
test <- nonpar.test(Xnew,Yhat,nsims=1000)
toReturn[iter] <- test$`estimated p-value`
}
Xhat
#find Qinit
d <- dim(Xhat)[2]
ds <- list()
for (c in 1:d) {
ds[[c]] <- c(-1,1)
}
signs <- expand.grid(ds)
obj.values <- rep(0,nrow(signs))
for (allsigns in c(1:nrow(signs))) {
obj.values[allsigns] <- kernel.stat(Xhat %*% diag(signs[allsigns,]),Yhat)
}
Qinit <- diag(signs[which.min(obj.values),])
Qinit
Qinit2 <- Qinit[c(2:d),c(2:d)]
#now OTP along negative parts:
toReturn <- OTP(Xhat[,c(2:d)],Yhat[,c(2:d)],Qinit =Qinit2,lambda=lambda,eps=eps,niter=niter)
niter=100
#now OTP along negative parts:
toReturn <- OTP(Xhat[,c(2:d)],Yhat[,c(2:d)],Qinit =Qinit2,lambda=lambda,eps=eps,niter=niter)
lambda = .1
#now OTP along negative parts:
toReturn <- OTP(Xhat[,c(2:d)],Yhat[,c(2:d)],Qinit =Qinit2,lambda=lambda,eps=eps,niter=niter)
toReturn$Q
#Qinit <- get_sign(Xhat,Yhat)
#Qinit2 <- Qinit[c((p+1):d),c((p+1):d)]
Q <- align_matrices_cheap(Xhat,Yhat,lambda=.1,eps=.1,niter=100)
#Q <- OTP(Xhat[,c((p+1):d)],Yhat[,c((p+1):d)],Qinit=Qinit2,lambda=.0001,eps=.0001,niter=300)
#Xnew <- Xhat%*% bdiag(Qinit[1,1],Q)
Xnew <- Xhat %*% Q
#run test:
test <- nonpar.test(Xnew,Yhat,nsims=1000)
test$`estimated p-value`
n <- 400
ns <- 400
epses <- 0
d <- 3
a <- .4
b <- .8
nsims <- 100
m <- n
B <- diag(a-b,d) + matrix(b,d,d)
B2 <- B + diag(eps,d)
nus1 <- eigen(B)
nus_true1 <- nus1$vectors %*% diag(abs(nus1$values)^(1/2),d,d)
nus2 <- eigen(B2)
nus_true2 <- nus2$vectors %*% diag(abs(nus2$values)^(1/2),d,d)
Ipq <- diag(c(1,rep(-1,(d-1))),d,d)
pis <- rep(1/d,d)
sigma <- 1/2
p <- 1
toReturn <- rep(0,nsims)
for (iter in c(1:nsims)) {
print(paste0("iter = ",iter, " of ",max(nsims)
,", n = ",n," of ",max(ns),
", eps = ",eps," of ",max(epses)))
assignmentvector1 <- rmultinom(n,1,pis)
assignmentvector2 <- rmultinom(m,1,pis)
Xtrue <-t(assignmentvector1) %*% nus_true1
Ytrue <-  t(assignmentvector2) %*% nus_true2
P1 <- Xtrue %*%Ipq %*% t(Xtrue)
P2 <- Ytrue %*% Ipq %*% t(Ytrue)
A <- generateAdjacencyMatrix(P1)
C <- generateAdjacencyMatrix(P2)
Xhat <- ase(A,d)
Yhat <- ase(C,d)
rm(A,C,P1,P2)
#Qinit <- get_sign(Xhat,Yhat)
#Qinit2 <- Qinit[c((p+1):d),c((p+1):d)]
Q <- align_matrices_cheap(Xhat,Yhat,lambda=.01,eps=.01,niter=100)
#Q <- OTP(Xhat[,c((p+1):d)],Yhat[,c((p+1):d)],Qinit=Qinit2,lambda=.0001,eps=.0001,niter=300)
#Xnew <- Xhat%*% bdiag(Qinit[1,1],Q)
Xnew <- Xhat %*% Q
#run test:
test <- nonpar.test(Xnew,Yhat,nsims=500)
toReturn[iter] <- test$`estimated p-value`
}
set.seed(472022)
ns <- 400
epses <- 0
d <- 3
a <- .4
b <- .8
nsims <- 10
m <- n
B <- diag(a-b,d) + matrix(b,d,d)
B2 <- B + diag(eps,d)
nus1 <- eigen(B)
nus_true1 <- nus1$vectors %*% diag(abs(nus1$values)^(1/2),d,d)
nus2 <- eigen(B2)
nus_true2 <- nus2$vectors %*% diag(abs(nus2$values)^(1/2),d,d)
Ipq <- diag(c(1,rep(-1,(d-1))),d,d)
pis <- rep(1/d,d)
sigma <- 1/2
p <- 1
toReturn <- rep(0,nsims)
for (iter in c(1:nsims)) {
print(paste0("iter = ",iter, " of ",max(nsims)
,", n = ",n," of ",max(ns),
", eps = ",eps," of ",max(epses)))
assignmentvector1 <- rmultinom(n,1,pis)
assignmentvector2 <- rmultinom(m,1,pis)
Xtrue <-t(assignmentvector1) %*% nus_true1
Ytrue <-  t(assignmentvector2) %*% nus_true2
P1 <- Xtrue %*%Ipq %*% t(Xtrue)
P2 <- Ytrue %*% Ipq %*% t(Ytrue)
A <- generateAdjacencyMatrix(P1)
C <- generateAdjacencyMatrix(P2)
Xhat <- ase(A,d)
Yhat <- ase(C,d)
rm(A,C,P1,P2)
#Qinit <- get_sign(Xhat,Yhat)
#Qinit2 <- Qinit[c((p+1):d),c((p+1):d)]
Q <- align_matrices_cheap(Xhat,Yhat,lambda=.01,eps=.01,niter=100)
#Q <- OTP(Xhat[,c((p+1):d)],Yhat[,c((p+1):d)],Qinit=Qinit2,lambda=.0001,eps=.0001,niter=300)
#Xnew <- Xhat%*% bdiag(Qinit[1,1],Q)
Xnew <- Xhat %*% Q
#run test:
test <- nonpar.test(Xnew,Yhat,nsims=500)
toReturn[iter] <- test$`estimated p-value`
}
toReturn <- rep(0,nsims)
for (iter in c(1:nsims)) {
print(paste0("iter = ",iter, " of ",max(nsims)
,", n = ",n," of ",max(ns),
", eps = ",eps," of ",max(epses)))
assignmentvector1 <- rmultinom(n,1,pis)
assignmentvector2 <- rmultinom(m,1,pis)
Xtrue <-t(assignmentvector1) %*% nus_true1
Ytrue <-  t(assignmentvector2) %*% nus_true2
P1 <- Xtrue %*%Ipq %*% t(Xtrue)
P2 <- Ytrue %*% Ipq %*% t(Ytrue)
A <- generateAdjacencyMatrix(P1)
C <- generateAdjacencyMatrix(P2)
Xhat <- ase(A,d)
Yhat <- ase(C,d)
rm(A,C,P1,P2)
#Qinit <- get_sign(Xhat,Yhat)
#Qinit2 <- Qinit[c((p+1):d),c((p+1):d)]
Q <- align_matrices_cheap(Xhat,Yhat,lambda=.01,eps=.01,niter=10)
#Q <- OTP(Xhat[,c((p+1):d)],Yhat[,c((p+1):d)],Qinit=Qinit2,lambda=.0001,eps=.0001,niter=300)
#Xnew <- Xhat%*% bdiag(Qinit[1,1],Q)
Xnew <- Xhat %*% Q
#run test:
test <- nonpar.test(Xnew,Yhat,nsims=500)
toReturn[iter] <- test$`estimated p-value`
}
toReturn
set.seed(472022)
ns <- 600
epses <- 0
d <- 3
a <- .4
b <- .8
nsims <- 10
m <- n
B <- diag(a-b,d) + matrix(b,d,d)
B2 <- B + diag(eps,d)
nus1 <- eigen(B)
nus_true1 <- nus1$vectors %*% diag(abs(nus1$values)^(1/2),d,d)
nus2 <- eigen(B2)
nus_true2 <- nus2$vectors %*% diag(abs(nus2$values)^(1/2),d,d)
Ipq <- diag(c(1,rep(-1,(d-1))),d,d)
pis <- rep(1/d,d)
sigma <- 1/2
p <- 1
toReturn <- rep(0,nsims)
for (iter in c(1:nsims)) {
print(paste0("iter = ",iter, " of ",max(nsims)
,", n = ",n," of ",max(ns),
", eps = ",eps," of ",max(epses)))
assignmentvector1 <- rmultinom(n,1,pis)
assignmentvector2 <- rmultinom(m,1,pis)
Xtrue <-t(assignmentvector1) %*% nus_true1
Ytrue <-  t(assignmentvector2) %*% nus_true2
P1 <- Xtrue %*%Ipq %*% t(Xtrue)
P2 <- Ytrue %*% Ipq %*% t(Ytrue)
A <- generateAdjacencyMatrix(P1)
C <- generateAdjacencyMatrix(P2)
Xhat <- ase(A,d)
Yhat <- ase(C,d)
rm(A,C,P1,P2)
#Qinit <- get_sign(Xhat,Yhat)
#Qinit2 <- Qinit[c((p+1):d),c((p+1):d)]
Q <- align_matrices_cheap(Xhat,Yhat,lambda=.01,eps=.01,niter=10)
#Q <- OTP(Xhat[,c((p+1):d)],Yhat[,c((p+1):d)],Qinit=Qinit2,lambda=.0001,eps=.0001,niter=300)
#Xnew <- Xhat%*% bdiag(Qinit[1,1],Q)
Xnew <- Xhat %*% Q
#run test:
test <- nonpar.test(Xnew,Yhat,nsims=500)
toReturn[iter] <- test$`estimated p-value`
}
ns <- 600
n <- ns[1]
epses <- 0
d <- 3
a <- .4
b <- .8
nsims <- 10
m <- n
B <- diag(a-b,d) + matrix(b,d,d)
B2 <- B + diag(eps,d)
nus1 <- eigen(B)
nus_true1 <- nus1$vectors %*% diag(abs(nus1$values)^(1/2),d,d)
nus2 <- eigen(B2)
nus_true2 <- nus2$vectors %*% diag(abs(nus2$values)^(1/2),d,d)
Ipq <- diag(c(1,rep(-1,(d-1))),d,d)
pis <- rep(1/d,d)
sigma <- 1/2
p <- 1
toReturn <- rep(0,nsims)
for (iter in c(1:nsims)) {
print(paste0("iter = ",iter, " of ",max(nsims)
,", n = ",n," of ",max(ns),
", eps = ",eps," of ",max(epses)))
assignmentvector1 <- rmultinom(n,1,pis)
assignmentvector2 <- rmultinom(m,1,pis)
Xtrue <-t(assignmentvector1) %*% nus_true1
Ytrue <-  t(assignmentvector2) %*% nus_true2
P1 <- Xtrue %*%Ipq %*% t(Xtrue)
P2 <- Ytrue %*% Ipq %*% t(Ytrue)
A <- generateAdjacencyMatrix(P1)
C <- generateAdjacencyMatrix(P2)
Xhat <- ase(A,d)
Yhat <- ase(C,d)
rm(A,C,P1,P2)
#Qinit <- get_sign(Xhat,Yhat)
#Qinit2 <- Qinit[c((p+1):d),c((p+1):d)]
Q <- align_matrices_cheap(Xhat,Yhat,lambda=.01,eps=.01,niter=10)
#Q <- OTP(Xhat[,c((p+1):d)],Yhat[,c((p+1):d)],Qinit=Qinit2,lambda=.0001,eps=.0001,niter=300)
#Xnew <- Xhat%*% bdiag(Qinit[1,1],Q)
Xnew <- Xhat %*% Q
#run test:
test <- nonpar.test(Xnew,Yhat,nsims=500)
toReturn[iter] <- test$`estimated p-value`
}
toReturn
eps_n_matrix
set.seed(472022)
ns <- 400
n <- ns[1]
epses <- 0
d <- 3
a <- .4
b <- .8
nsims <- 100
m <- n
B <- diag(a-b,d) + matrix(b,d,d)
B2 <- B + diag(eps,d)
nus1 <- eigen(B)
nus_true1 <- nus1$vectors %*% diag(abs(nus1$values)^(1/2),d,d)
nus2 <- eigen(B2)
nus_true2 <- nus2$vectors %*% diag(abs(nus2$values)^(1/2),d,d)
Ipq <- diag(c(1,rep(-1,(d-1))),d,d)
pis <- rep(1/d,d)
sigma <- 1/2
p <- 1
toReturn <- rep(0,nsims)
for (iter in c(1:nsims)) {
print(paste0("iter = ",iter, " of ",max(nsims)
,", n = ",n," of ",max(ns),
", eps = ",eps," of ",max(epses)))
assignmentvector1 <- rmultinom(n,1,pis)
assignmentvector2 <- rmultinom(m,1,pis)
Xtrue <-t(assignmentvector1) %*% nus_true1
Ytrue <-  t(assignmentvector2) %*% nus_true2
P1 <- Xtrue %*%Ipq %*% t(Xtrue)
P2 <- Ytrue %*% Ipq %*% t(Ytrue)
A <- generateAdjacencyMatrix(P1)
C <- generateAdjacencyMatrix(P2)
Xhat <- ase(A,d)
Yhat <- ase(C,d)
rm(A,C,P1,P2)
#Qinit <- get_sign(Xhat,Yhat)
#Qinit2 <- Qinit[c((p+1):d),c((p+1):d)]
Q <- align_matrices_cheap(Xhat,Yhat,lambda=.01,eps=.01,niter=10)
#Q <- OTP(Xhat[,c((p+1):d)],Yhat[,c((p+1):d)],Qinit=Qinit2,lambda=.0001,eps=.0001,niter=300)
#Xnew <- Xhat%*% bdiag(Qinit[1,1],Q)
Xnew <- Xhat %*% Q
#run test:
test <- nonpar.test(Xnew,Yhat,nsims=500)
toReturn[iter] <- test$`estimated p-value`
}
toReturn
sum(toReturn < .05)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
sum(toReturn < .05)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
sum(toReturn <= .05)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
niter
nsims
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
Xhat
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
Xhat
d <- dim(Xhat)[2]
ds <- list()
for (c in 1:d) {
ds[[c]] <- c(-1,1)
}
signs <- expand.grid(ds)
obj.values1 <- rep(0,nrow(signs))
obj.values2 <- rep(0,nrow(signs))
Q_news <- list()
for (allsigns in c(1:nrow(signs))) {
obj.values1[allsigns] <- kernel.stat(Xhat %*% diag(signs[allsigns,]),Yhat)
Qinit1 <- diag(signs[allsigns,])
Qinit2 <- Qinit[c(2:d),c(2:d)]
Q_news[[allsigns]] <- OTP(Xhat[,c(2:d)],Yhat[,c(2:d)],Qinit =Qinit2,lambda=lambda,eps=eps,niter=niter)
obj.values2[allsigns] <- kernel.stat(Xhat %*% bdiag(Qinit[1,1],Q_news[[allsigns]]),Yhat)
}
eps <- .01
lambda = .1
niter =10
for (allsigns in c(1:nrow(signs))) {
obj.values1[allsigns] <- kernel.stat(Xhat %*% diag(signs[allsigns,]),Yhat)
Qinit1 <- diag(signs[allsigns,])
Qinit2 <- Qinit[c(2:d),c(2:d)]
Q_news[[allsigns]] <- OTP(Xhat[,c(2:d)],Yhat[,c(2:d)],Qinit =Qinit2,lambda=lambda,eps=eps,niter=niter)
obj.values2[allsigns] <- kernel.stat(Xhat %*% bdiag(Qinit[1,1],Q_news[[allsigns]]),Yhat)
}
for (allsigns in c(1:nrow(signs))) {
obj.values1[allsigns] <- kernel.stat(Xhat %*% diag(signs[allsigns,]),Yhat)
Qinit1 <- diag(signs[allsigns,])
Qinit2 <- Qinit[c(2:d),c(2:d)]
Q_news[[allsigns]] <- OTP(Xhat[,c(2:d)],Yhat[,c(2:d)],Qinit =Qinit2,lambda=lambda,eps=eps,niter=niter)
obj.values2[allsigns] <- kernel.stat(Xhat %*% bdiag(Qinit[1,1],Q_news[[allsigns]]),Yhat)
}
Q_news[[allsigns]] <- OTP(Xhat[,c(2:d)],Yhat[,c(2:d)],Qinit =Qinit2,lambda=lambda,eps=eps,niter=niter)
Q_news[[alsigns]]
Q_news[[allsigns]]
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/align.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/align.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/align.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
11/50
sum(toReturn <= .1)/nsims
sum(toReturn <= .1)/nsims - .1
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
sum(toReturn<=.05)
sum(toReturn<=.05)Q
Q
d  <- dim(Q)[1]
Qp <- Q[c(1:p),c(1:p)]
Qq <- Q[c((p+1):d),c((p+1):d)]
svd1 <- svd(Qp)
svd2 <- svd(Qq)
d  <- dim(Q)[1]
Qp <- Q[c(1:p),c(1:p)]
Qq <- Q[c((p+1):d),c((p+1):d)]
svd1 <- svd(Qp)
svd2 <- svd(Qq)
bdiag(svd1$u%*%svd1$v,svd2$u%*%svd2$v)
Q
opq_project <- function(Q,p,q) {
d  <- dim(Q)[1]
Qp <- Q[c(1:p),c(1:p)]
Qq <- Q[c((p+1):d),c((p+1):d)]
svd1 <- svd(Qp)
svd2 <- svd(Qq)
return(bdiag(svd1$u%*%svd1$v,svd2$u%*%svd2$v))
}
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/align.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/align.R", echo=TRUE)
source("C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/simulations_revision/power_curves/misc_functions/tests.R", echo=TRUE)
sum(toreturn <= .05)
sum(toReturn <= .05)/nsims
toReturn
